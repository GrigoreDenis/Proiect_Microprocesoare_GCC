# daca vrei sa convertesti un fisier .ui in .py, deschizi cmd si tastezi
# pyuic5 -x UI_FILE -o PY_OUTPUT_FILE

# liniile de mai jos reprezinta continutul lui PY_OUTPUT_FILE plus cateva adaugari facute de mine


# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'form.ui'
#
# Created by: PyQt5 UI code generator 5.15.7
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys
import random
import matplotlib
import serial
import serial.tools.list_ports
from PyQt5 import QtCore, QtGui, QtWidgets
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure


matplotlib.use('Qt5Agg')

ports = serial.tools.list_ports.comports()


for port, desc, hwid in sorted(ports):
    main_port = port
    
n_data = 50 # nr de puncte pe axele x si y
Y_senzor1 = [0 for i in range(n_data)]
        
width = 300
height = 200

baudrate = 115200
ser = serial.Serial(main_port,baudrate,timeout=0.5)
ser.write('a'.encode())
data = ser.readline()
# apeleaza functia de mai jos pentru a putea actualiza graficul cu datele receptionate de un anumit senzor
def update_valoare_primita(senzor, y):
    #print(y)
    global Y_senzor1
    
    if senzor == "senzor1":
        Y_senzor1 = Y_senzor1[1:] + [y]
    elif senzor == "None":
        Y_senzor1 = Y_senzor1[1:] + [0]
    else:
        print("Eroare! In variabila senzor trebuie sa imi spui pentru ce senzor vrei sa fac update-ul coordonatelor")
        Y_senzor1 = Y_senzor1[1:] + [0]

# deseneaza graficele
class MplCanvas(FigureCanvas):

    def __init__(self):
        fig = Figure(figsize=(width, height), dpi=100)
        self.axes = fig.add_subplot(111)
        super(MplCanvas, self).__init__(fig)

# interfata grafica      
class Ui_Widget(object):
    def setupUi(self, Widget): # initializare interfata grafica
        Widget.setObjectName("Widget")
        Widget.resize(800, 600)
        self.gridLayoutWidget = QtWidgets.QWidget(Widget)
        self.gridLayoutWidget.setGeometry(QtCore.QRect(50, 60, 681, 501))
        self.gridLayoutWidget.setObjectName("gridLayoutWidget")
        self.gridLayout = QtWidgets.QGridLayout(self.gridLayoutWidget)
        self.gridLayout.setContentsMargins(0, 0, 0, 0)
        self.gridLayout.setObjectName("gridLayout")
        
        self.senzor1_button = QtWidgets.QPushButton(self.gridLayoutWidget)
        self.senzor1_button.setObjectName("senzor1_button")
        self.gridLayout.addWidget(self.senzor1_button, 1, 0, 1, 1)
        self.grid_senzor1 = QtWidgets.QGridLayout()
        self.grid_senzor1.setObjectName("grid_senzor1")
        self.gridLayout.addLayout(self.grid_senzor1, 0, 0, 1, 1)
        self.canvas_senzor1 = MplCanvas()
        self.grid_senzor1.addWidget(self.canvas_senzor1)
        
        
        # initializare coordonate grafice
        self.xdata = list(range(n_data))
        self.ydata_senzor1 = Y_senzor1
        
        self.senzor_running = "senzor1" # ca sa stiu de pe ce senzor citesc None pt nimic
        
        # initializare timer (asigura citirea real time)
        self.timer = QtCore.QTimer()
        self.timer.setInterval(1)
        self.timer.timeout.connect(self.update_plot_senzori)
        self.timer.start()

        self.retranslateUi(Widget)
        QtCore.QMetaObject.connectSlotsByName(Widget)

    def retranslateUi(self, Widget): # detalii butoane
        _translate = QtCore.QCoreApplication.translate
        Widget.setWindowTitle(_translate("Widget", "Widget"))
        self.senzor1_button.setText(_translate("Widget", "Switch Senzor"))
        self.senzor1_button.clicked.connect(self.senzor1_afisare_grafic)
             
    def redeseneaza_graficele(self):
        self.canvas_senzor1.axes.cla()
        self.canvas_senzor1.axes.plot(self.xdata, self.ydata_senzor1, 'r')
        self.canvas_senzor1.draw()
        
    def update_plot_senzori(self): # actualizeaza graficele cu valorile receptionate
        global Y_senzor1

        try:

            ser.write('a'.encode())
            data = ser.readline()
            update_valoare_primita(self.senzor_running, float((str(data).split("V")[0].split("'")[1].split('r')[1])))
        except:
            pass
            
        self.ydata_senzor1 = Y_senzor1
        self.redeseneaza_graficele()
            
    def senzor1_afisare_grafic(self, Widget): # connector pt butonul specific senzorului 1
        self.senzor_running = "senzor1"
        ser.write('\r\n'.encode())

if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Widget = QtWidgets.QWidget()
    ui = Ui_Widget()
    ui.setupUi(Widget)
    Widget.show()
    app.exec_()
